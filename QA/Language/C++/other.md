# C++
### 1.gcc编译c++文件
利用-o 编译成目标文件  
利用-lstdc++ 选项或者g++命令链接(这是因为gcc是不会自动c++程序的库)

### 2.gdb调试
-c 的时候要添加-g参数
  
### 3.lower bound 和upper bound的区别
lower bound是用来寻找第一个元素大于或等于目标值(下界),大于等于  
upper bound是用来寻找第一个大于目标值的元素(上界),大于

### 4.sizeof
用于返回对象或类型的字节大小  
**注意:**  
* 数组作为函数参数问题
> 由于`sizeof(*ptr)`会返回4或者8(这个由计算机决定),所以当在函数中时候,`sizeof( <function arguments>)`的时候需要注意,如果传入的参数为数组的时候,传参的时候会默认把参数识别为指针类型,这时候并不会返回数组的字节数
* sizeof 和 strlen区别
> 首先 sizeof适用于所有类型,而strlen是适用于字符串(char*) , 其次sizeof返回的是该字符串的长度+1,因为字符串的最后一个字符`'\0'`也会被计算在内,而strlen只会计算到`'\0'`前的一个字符,是真正意义上的字符串长度

### 5.数组指针和指针数组区别
#### 5.1.数组指针
实例：`int (*p)[n]`
> 指向数组类型的指针

原因：`()`的优先级更高，所以说明p是指针
#### 5.2.指针数组
实例：`int *p[n]`
> 数组中各个元素均为指针

原因：`[]`的优先级更高，所以p是数组

### 6.函数指针和指针函数
#### 6.1.函数指针
实例：`int (*fun)(int x, int y)`
> 指向函数的指针

#### 6.2.指针函数
实例：`int* fun()`
> 返回指针的函数

### 7.函数对象(function object)
允许一个程序设计的对象被当作普通函数调用
#### 7.1.函数类
如果一个类重载了`()`,这个类就是函数对象类，这个类的对象就是函数对象
##### 与普通函数相比，优点
* 函数对象可以有自己的状态，这是普通函数所没有的
* 函数对象有自己特定的类型
#### 7.2.Lambda
其本质就是函数类，不过是在代码编译的时候自动转换为一个类
#### 7.3.std::function类
抽象了函数对象的参数值和返回值，可用于指向同一函数参数和返回值的普通函数、函数指针、lambda函数、函数对象
#### 7.4.std::bind和闭包
创建闭包

#### 7.5.与函数指针区别
1. 编译器可以内联执行函数对象的调用(inline)
2. 函数对象内部可以保持状态

### 8.内联函数
编译器将指定的函数体插入并取代每一处调用该函数的地方，从而节省了每次调用函数带来的额外时间开支，但会增大占用空间
#### 8.1.与宏比较\(C\)
* 宏调用不执行类型检查
* C语言的宏使用只是文本替换

### 9.左值，右值，右值引用

#### 左值和右值的简单理解
左值：可以取地址  
右值：不能取地址，包括临时值

#### 右值引用`&&`
让右值也可以引用，在调用结束后，右值引用就会被销毁。
> 引用`&`只能用于左值

#### 链接
[左右](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)


### 10.new
##### 用处
用于动态分配内存、并调用构造函数初始化内存
##### 内部实现
1. 调用相应的operator new()函数，动态分配内存。如果operator new()不能成功获得内存，则调用new_handler函数。如果没有设置new_handler函数或者new_handler未能分配足够内存，则抛出std::bad_alloc异常。其中"new运算符表达式"所调用的operator new()函数，按照C++的名字查找规则(ADL)查找，在要申请内存的数据类型T的内部、数据类型T定义处的名字空间查找；如果没有，则调用全局::operator new()函数 
> new_handler相关请看第14点  
> ::operator new()类似与malloc，只用于分配内存，但不进行构造

2. 在分配到的内存块上初始化相应类型的对象并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用operator delete()函数释放已经分配到的内存
##### 用法
普通用法
~~~C++
// initializer是传递给构造函数的实参表或初值
p_var = new type(initializer)
~~~

动态生成对象数组
~~~c++
// C++98是不允许徐显示初始化，但C++11后允许
p_var = new type [size] {initial-value}
~~~

带位置的new(placement new)
~~~c++
// 在指定的地址调用构造函数
new (expression-list) new-type-id (optional-initializer-expression-list)

//sample
void *buffer = ::operator new(sizeof(string))
buffer = new(buffer) string("abd");
~~~






### 11.const 和 *(指针) 和 &(引用)关系
#### 11.1.const和*(指针)的关系
##### const int * p
即(const int * ) p, 指向常量的指针，这意味着指针可变，指针指向的变量不可变
##### int * const p
即int * (const p), 常指针，这意味着指针不可变，但指针指向的变量是可变的
##### const int * const p
指向常量的常指针，这意味着指针不可变，指针指向的变量也是不可变

#### 11.2 const和&(常引用)
不带const修饰的引用&是左值引用，而常引用(带了const)可以引用右值
> 常引用即引用是常量，但被引用的变量没有作限定

### 12. `::`作用
`::`为作用域符，其作用如下
* 作为全局作用域符，类似`::name`
* 类作用域符号，类似`class::name`
* 命名空间作用域符，类似`namespace::name`

### 13. ADL(Argument-dependent lookup)查找
该查找是一组对函数调用表达式(包括对重载运算符的隐式调用)中的无限定函数名进行查找的规则，在通常无限定名字查找所考虑的作用域和命名空间之外，还考虑实参的命名空间

### 14. new_handler
##### 用处
用于处理operator new操作符不能满足请求的情况，该函数是在抛出异常前调用，且可由用户自定
##### 用法
new_handler为指向一个没有参数返回值的函数。而制定出错处理函数需要用到set_new_handler函数，该函数是一个输入参数为operator new分配内存失败时调用出错处理函数的指针，返回值为set_new_handler函数没调用之前的已经在起作用的旧的函数处理函数指针
##### 实际
new_handler函数不是简单检测出错后然后停止程序，而是去处理出错，使得下一次内存分配可以成功，一般从以下几个方面入手：
1. 产生更多的可用内存
2. 安装另一个不同版本的new_handler函数
3. 卸载new_handler
4. 抛出bad_alloc异常或其派生异常
5. 没有返回，调用abort或exit

### 15. ptddff_t 和 size_t区别
##### ptddff_t
用来保存两个指针的减法操作的结果,是有符号类型
##### size_t
通常用来表示数组的长度，无符号类型
##### 区别
ptddff_t是减法操作的结果，那么结果就有可能为负值，而sizt_t必须为正数

### 16. template
> TODO:  <07-02-21, yourname> 
