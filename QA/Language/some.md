#some.md

### Build 过程（编译和链接）
以下例子均由C来进行
#### 预处理(prepressing)
处理以`#`开始的预编译指令
* 展开`#define`
* 处理条件预编译`#if`等
* 递归处理`#include`(文本替换)
* 删除注释
* 添加行号和文件名标识符，便于编译时编译器产生调试用的行号信息
* 保留`#pragma`

代码
~~~C++
gcc -E hello.c -o hello.i
//或者
cpp hello.c > hello.i
~~~

#### 编译(compilation)
词法分析，语法分析，语义分析，优化等汇编代码

代码
~~~C++
gcc -S hello.i -o hello.s
~~~

#### 汇编(Assembly)
将汇编代码转变为机器可以执行的指令

代码
~~~C++
as hello.s -o hello.o
//或者
gcc hello.c -o hello.o
~~~

#### 链接(Linking)
> 为了模块化

* 地址和空间分配
* 符号决议(符号绑定，地址绑定)
* 重定位

相关指令`ld`

##### 静态链接
对符号进行重定位

### 目标文件
目标文件是源代码编译后但未进行链接的中间文件(Windows的.obj和Linux的.o)，其与可执行文件的格式很相似(广义上几乎是一样的)

动态链接库(.dll/.so)和静态链接库(.lib/.a)都是按照可执行文件格式存储

#### 内容格式
* 文件头
> 描述整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址，硬件信息等  
> 还包含段表，描述各个段在文件的偏移位置和段的属性
* 代码段(.code/.text)
> 存放编译后的机器指令
* 数据段(.data)
> 存放全局变量和局部静态变量
* .bss段
> 用于记录未初始化的全局变量和局部静态变量的大小总和
* 只读数据段(.rodata)
* 注释信息段(.comment)
> 一般是编译器版本信息
* 堆栈提示段(.note.GNU-stack)

分成数据段和代码段的优点：
* 有利于设置权限，以防止程序的指令被有意或无意的改写
* 现在的CPU缓存分为数据缓存和指令缓存，有利于提高CPU对缓存的命中率
* 多个副本运行时只需保留一份程序的指令部分(只读的内存部分)，可节省大量内存

指令：  
`objdump`用于查看obj文件  
`readelf`同上(elf)  
`size`用于查看各个段的长度  
`objcopy`用于将一个二进制数据作为一个新段
`nm`查看符号表

##### elf文件
* 魔数
  * 头四个字节必定为(0x7f-DEL,0x45-'E',0x4c-'L',0x46-'F')
  * 第五个字节是表示位数(0x01-32,0x02-64)

