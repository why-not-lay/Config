# 编译和链接

### 1.Build 过程（编译和链接）
以下例子均由C来进行
#### 1.1.预处理(prepressing)
处理以`#`开始的预编译指令
* 展开`#define`
* 处理条件预编译`#if`等
* 递归处理`#include`(文本替换)
* 删除注释
* 添加行号和文件名标识符，便于编译时编译器产生调试用的行号信息
* 保留`#pragma`

代码
~~~C++
gcc -E hello.c -o hello.i
//或者
cpp hello.c > hello.i
~~~

#### 1.2.编译(compilation)
词法分析，语法分析，语义分析，优化等汇编代码

代码
~~~C++
gcc -S hello.i -o hello.s
~~~

#### 1.3.汇编(Assembly)
将汇编代码转变为机器可以执行的指令

代码
~~~C++
as hello.s -o hello.o
//或者
gcc hello.c -o hello.o
~~~

#### 1.4.链接(Linking)
> 为了模块化

* 地址和空间分配
* 符号决议(符号绑定，地址绑定)
* 重定位

相关指令`ld`

##### 静态链接
对符号进行重定位

### 2.目标文件
目标文件是源代码编译后但未进行链接的中间文件(Windows的.obj和Linux的.o)，其与可执行文件的格式很相似(广义上几乎是一样的)

动态链接库(.dll/.so)和静态链接库(.lib/.a)都是按照可执行文件格式存储

#### 2.1.内容格式
* 文件头
> 描述整个文件的文件属性，包括文件是否可执行，是静态链接还是动态链接及入口地址，硬件信息等  
> 还包含段表，描述各个段在文件的偏移位置和段的属性
* 代码段(.code/.text)
> 存放编译后的机器指令
* 数据段(.data)
> 存放全局变量和局部静态变量
* .bss段
> 用于记录未初始化的全局变量和局部静态变量的大小总和
* 只读数据段(.rodata)
* 注释信息段(.comment)
> 一般是编译器版本信息
* 堆栈提示段(.note.GNU-stack)

分成数据段和代码段的优点：
* 有利于设置权限，以防止程序的指令被有意或无意的改写
* 现在的CPU缓存分为数据缓存和指令缓存，有利于提高CPU对缓存的命中率
* 多个副本运行时只需保留一份程序的指令部分(只读的内存部分)，可节省大量内存

指令：  
`objdump`用于查看obj文件  
`readelf`同上(elf)  
`size`用于查看各个段的长度  
`objcopy`用于将一个二进制数据作为一个新段
`nm`查看符号表

##### elf文件
* 魔数
  * 头四个字节必定为(0x7f-DEL,0x45-'E',0x4c-'L',0x46-'F')
  * 第五个字节是表示位数(0x01-32,0x02-64)

#### 2.2.符号Symbol
符号：函数和变量的统称
> 链接的本质

分类：
* 定义在本目标文件的全局符号
* 本目标文件的引用的全局符号
* 段名
> 一般由编译器产生
* 局部符号
> 只在编译单元内部可见，对于链接过程是没有作用
* 行号信息

##### 符号表
往往是文件中的一个段，段名为.symtab

指令：`readelf -s`

##### 特殊符号
这些符号并没有在程序中定义，但是我们可以直接声明并且引用它，只有在ld链接生产最终可执行文件的时候这些符号才会存在
> 这些符号被定义在ld链接器的链接脚本里

例如：
* __executable_start
> 程序起始地址（不是入口地址），是程序最开始的地方
* __etext或_etext或etext
> 代码段结束地址，即代码段末尾地址
* edata或_edata
> 数据段结束地址
* _end 或 end
> 程序结束地址

##### 符号修饰和函数签名
为了解决同名问题

##### extern "C"
C++编译器会将在extern "C"大括号内部的代码当作是C语言代码处理

为什么需要：
> 在C++链接C的模块时，由于C++存在符号修饰的关系，原来代码中的符号在经过编译后会变成一个新的符号名，但在C语言中，符号修饰是几乎不存在的，这是如果在C++中调用了C的符号就会出现找不到符号的结果，最后就会链接失败。

为了让头文件均兼容C++和C
~~~C++
#ifdef __cplusplus
extern "C" {
#endif

//code

#ifdef __cplusplus
}
#endif
~~~

##### 强/弱符号
默认情况下：  
强符号：函数和初始化了的全局变量  
弱符号：未初始化的全局变量或用`__attribute__((weak))`修饰的符号

规则：
* 不允许强符号多次被定义
* 如果一个符号在某个文件中是强符号，而在其他文件是弱符号，那么选择强符号
* 如果一个符号在所有的目标文件中都是弱符号，那么选择占用空间最大的一个

###### 强/弱引用
强引用：链接时未找到相关的符号定义，随后报错  
弱引用：链接时未找到相关的符号定义，但不报错，默认其为0或是一个特殊值

#### 2.2.调试信息


指令：`gcc/g++ -g`

去掉调试信息：`strip`
