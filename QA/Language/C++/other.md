# C++
### gcc编译c++文件
利用-o 编译成目标文件  
利用-lstdc++ 选项或者g++命令链接(这是因为gcc是不会自动c++程序的库)

### gdb调试
-c 的时候要添加-g参数
### [编译步骤](http://www.ruanyifeng.com/blog/2014/11/compiler.html)
  1. 配置(configure)
  2. 确定标准库和头文件位置
  3. 确定依赖关系
  4. 头文件的预编译(precompilation)
    > 编译源码之前,先编译头文件,保证了头文件只编译一次.  
    > 并非头文件所有的内容都会被预编译,用来声明宏#define命令的是不会被预编译
  5. 预处理(preprocessing)
    > 替换源码中的头文件和宏
  6.编译(compilation)
    > 生成机器码  
    > 转码后的文件称为对象文件(object file),此时还未能执行
  7. 连接(Linking)
    > 把外部函数的代码添加到可执行文件(在内存中)中(静态连接)  
    > 动态连接
  8. 安装(Installation)
    > 将内存的可执行文件保存到用户事先指定的目录
  9. 操作系统连接
  10. 生成安装包
  11. 动态连接(Dynamic linking)
    > 只在运行时候连接  
    > Linux-- *.so /  Windows-- *.dll / Mac-- *.dylib
  
### lower bound 和upper bound的区别
lower bound是用来寻找第一个元素大于或等于目标值(下界),大于等于  
upper bound是用来寻找第一个大于目标值的元素(上界),大于

### sizeof
用于返回对象或类型的字节大小  
**注意:**  
* 数组作为函数参数问题
> 由于`sizeof(*ptr)`会返回4或者8(这个由计算机决定),所以当在函数中时候,`sizeof( <function arguments>)`的时候需要注意,如果传入的参数为数组的时候,传参的时候会默认把参数识别为指针类型,这时候并不会返回数组的字节数
* sizeof 和 strlen区别
> 首先 sizeof适用于所有类型,而strlen是适用于字符串(char*) , 其次sizeof返回的是该字符串的长度+1,因为字符串的最后一个字符`'\0'`也会被计算在内,而strlen只会计算到`'\0'`前的一个字符,是真正意义上的字符串长度

### 数组指针和指针数组区别
#### 数组指针
实例：`int (*p)[n]`
> 指向数组类型的指针

原因：`()`的优先级更高，所以说明p是指针
#### 指针数组
实例：`int *p[n]`
> 数组中各个元素均为指针

原因：`[]`的优先级更高，所以p是数组

### 函数指针和指针函数
#### 函数指针
实例：`int (*fun)(int x, int y)`
> 指向函数的指针

#### 指针函数
实例：`int* fun()`
> 返回指针的函数

### 函数对象(function object)
允许一个程序设计的对象被当作普通函数调用
#### 函数类
如果一个类重载了`()`,这个类就是函数对象类，这个类的对象就是函数对象
##### 与普通函数相比，优点
* 函数对象可以有自己的状态，这是普通函数所没有的
* 函数对象有自己特定的类型
#### Lambda
其本质就是函数类，不过是在代码编译的时候自动转换为一个类
#### std::function类
抽象了函数对象的参数值和返回值，可用于指向同一函数参数和返回值的普通函数、函数指针、lambda函数、函数对象
#### std::bind和闭包
创建闭包

#### 与函数指针区别
1. 编译器可以内联执行函数对象的调用(inline)
2. 函数对象内部可以保持状态

### 内联函数
编译器将指定的函数体插入并取代每一处调用该函数的地方，从而节省了每次调用函数带来的额外时间开支，但会增大占用空间
#### 与宏比较\(C\)
* 宏调用不执行类型检查
* C语言的宏使用只是文本替换

### 左值，右值，右值引用

#### 左值和右值的简单理解
左值：可以取地址  
右值：不能取地址，包括临时值

#### 右值引用`&&`
让右值也可以引用，在调用结束后，右值引用就会被销毁。
> 引用`&`只能用于左值

#### 链接
[左右](https://nettee.github.io/posts/2018/Understanding-lvalues-and-rvalues-in-C-and-C/)

