# 内存管理
### 无存储器抽象

  ![3.1](./pic/3.1.png)

### 存储器抽象
* 地址空间
  > 是一个进程可用于寻址寻址内存的一套地址集合
  * 基址寄存器与界限寄存器
    * 动态重定位
      > 把每个进程的地址空间映射到物理内存的不同部分
      * 缺点
        > 每次重定位都需要进行加法和比较运算,如果么有特殊的电路下，效率比较慢
  * 交换技术
    > 内存不足问题
    * 交换
      > 把一个进程完整调入内存,使该进程运行一段时间,然后把它存回磁盘
      * 内存紧缩
        > 交换使得内存产生多个空闲区(空洞),通过把所有进程尽可能下下移动,把小的空闲区合成一大块
    * 虚拟内存
      > 程序能在只有一部分被调入内存的情况下运行
  * 空闲内存管理
    * 使用位图的存储管理
      ![3.6](./pic/3.6.png)  
      > 内存的大小和分配单元的大小决定的位图的大小
    * 使用链表的内存管理
      * 首次适配算法
        > 遍历段链表,直至找到足够进程使用的空闲区
      * 下次适配算法
        > 和首次适配算法类似,但每次的结束点为下一次的起始点
      * 最佳适配算法
        > 遍历整段链表,找出能够容纳进程的最小空闲区
      * 最差适配算法
        > 遍历整段链表,找出能够容纳进程的最大空闲区
      * 快速适配算法
        > 创建常用大小的空闲区维护单独的链表(n项表),例如第一项指向大小4KB的空闲区链表表头指针,第二项指向8KB空闲区链表表头指针,... 
        * 缺点
          > 一个进程终止或被换出时候,合并相邻块耗时,如果不合并机会分裂大量进程无法利用的小空闲区
  * 虚拟内存
    > 每个程序拥有自己的地址空间,每个空间被分割多个个块,每一块称作一页(页面),每一页有连续的地址范围,这些页被映射到物理内存.当程序引用到一部分在物理内存中的地址空间时,硬件立刻执行必要的映射,若引用的那部分不在物理内存中时,有操作系统负责将缺失的部分装入物理内存
    * 分页
      > * 虚拟地址:由程序产生的地址,虚拟地址不是直接送到内存总线上,而是送到内存管理单元(MMU),MMU把虚拟地址映射为物理内存地址
      > * 页面: 虚拟地址空间按照固定大小划分的单元
      > * 页框: 物理内存中对应于页面的单元
